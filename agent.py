import mathimport timeimport openaiimport randomimport google.generativeai as genaiimport utilfrom log.custom_logger import logfrom prompt.agent_prompt import *from PromptCoder.procoder.functional import format_promptfrom PromptCoder.procoder.prompt import *#   随机生成股票市场模拟中用户的初始状态def random_init(stock_a_initial, stock_b_initial):    # 初始化    # 股票A和股票B的数量、现金和债务金额    stock_a, stock_b, cash, debt_amount = 0.0, 0.0, 0.0, 0.0    # 随机生成符合条件的初始的股票数量、现金和债务金额    while stock_a * stock_a_initial + stock_b * stock_b_initial + cash < util.MIN_INITIAL_PROPERTY \            or stock_a * stock_a_initial + stock_b * stock_b_initial + cash > util.MAX_INITIAL_PROPERTY \            or debt_amount > stock_a * stock_a_initial + stock_b * stock_b_initial + cash:        # 随机生成数据        stock_a = int(random.uniform(0, util.MAX_INITIAL_PROPERTY / stock_a_initial))        stock_b = int(random.uniform(0, util.MAX_INITIAL_PROPERTY / stock_b_initial))        cash = random.uniform(0, util.MAX_INITIAL_PROPERTY)        debt_amount = random.uniform(0, util.MAX_INITIAL_PROPERTY)    # 创建一个包含债务信息的字典    # 是否贷款、贷款金额、贷款类型、还款日期等信息    debt = {        "loan": "yes",        "amount": debt_amount,        "loan_type": random.randint(0, len(util.LOAN_TYPE) - 1),        "repayment_date": random.choice(util.REPAYMENT_DAYS)    }    # 返回股票A数量、股票B数量、现金金额和债务信息    return stock_a, stock_b, cash, debt# def random_init(stock_initial_price):#     stock, cash, debt_amount = 0.0, 0.0, 0.0#     while stock * stock_initial_price + cash < util.MIN_INITIAL_PROPERTY \#             or stock * stock_initial_price + cash > util.MAX_INITIAL_PROPERTY \#             or debt_amount > stock * stock_initial_price + cash:#         stock = int(random.uniform(0, util.MAX_INITIAL_PROPERTY / stock_initial_price))#         cash = random.uniform(0, util.MAX_INITIAL_PROPERTY)#         debt_amount = random.uniform(0, util.MAX_INITIAL_PROPERTY)#     debt = {#         "loan": "yes",#         "amount": debt_amount,#         "loan_type": random.randint(0, len(util.LOAN_TYPE)),#         "repayment_date": random.choice(util.REPAYMENT_DAYS)#     }#     return stock, cash, debtclass Agent:    def __init__(self, i, stock_a_price, stock_b_price, secretary, model):        # 初始化Agent实例        self.order = i  # 标识符        self.secretary = secretary  # 秘书        self.model = model  # 模型 GPT Gemini        self.character = random.choice(["Conservative", "Aggressive", "Balanced", "Growth-Oriented"])        # 性格：保守型 进取型 平衡型 增长型        # 初始化：股票数量 现金 债务信息        self.stock_a_amount, self.stock_b_amount, self.cash, init_debt = random_init(stock_a_price, stock_b_price)        # self.stock_b_amount = 0  # 股票数量以手为单位存储，一手=10股，股价实际是一手的价格        self.init_proper = self.get_total_proper(stock_a_price, stock_b_price)        # 初始资产值计算，在后续借贷时不能超过这个初始资产值        # 初始化行动历史记录和聊天历史记录        self.action_history = [[] for _ in range(util.TOTAL_DATE)]  # 每一天的行动历史        self.chat_history = []  # 与模型的聊天历史        self.loans = [init_debt]  # 初始贷款信息存储在列表中        self.is_bankrupt = False  # 标记Agent是否破产        self.quit = False  # 标记Agent是否退出市场    def run_api(self, prompt, temperature: float = 1):        # 根据模型名称选择对应的API调用方法        if 'gpt' in self.model:            return self.run_api_gpt(prompt, temperature)        elif 'gemini' in self.model:            return self.run_api_gemini(prompt, temperature)    def run_api_gemini(self, prompt, temperature: float = 1):        # 配置Gemini API的相关信息        genai.configure(api_key=util.GOOGLE_API_KEY, transport='rest')        generation_config = genai.types.GenerationConfig(            candidate_count=1,  # 生成一个候选回复            temperature=temperature)  # 设置生成内容的温度影响输出的随机性        model = genai.GenerativeModel(self.model)  # 创建Gemini生成模型实例        self.chat_history.append({"role": "user", "parts": [prompt]})  # 将用户的输入添加到聊天历史中        max_retry = 2  # 最大重试次数        retry = 0        while retry < max_retry:            try:                # 调用Gemini模型生成回复内容                response = model.generate_content(contents=self.chat_history, generation_config=generation_config)                new_message_dict = {"role": 'model', "parts": [response.text]}  # 构建模型回复信息                self.chat_history.append(new_message_dict)  # 将模型的回复添加到聊天历史中                return response.text  # 返回模型的回复文本            except Exception as e:                log.logger.warning("Gemini api retry...{}".format(e))  # 记录API调用失败的警告日志                retry += 1                time.sleep(1)  # 等待一秒后重试        log.logger.error("ERROR: GEMINI API FAILED. SKIP THIS INTERACTION.")        # 如果API调用失败，返回空字符串        return ""    def run_api_gpt(self, prompt, temperature: float = 1):        # 配置OpenAI API的相关信息        openai.api_key = util.OPENAI_API_KEY  # 设置OpenAI的API密钥        openai.base_url = util.OPENAI_BASE_URL   # 设置OpenAI的Base URL        client = openai.OpenAI(api_key=openai.api_key, base_url=openai.base_url)  # 创建OpenAI API客户端        self.chat_history.append({"role": "user", "content": prompt})  # 将用户的输入添加到聊天历史中        max_retry = 2  # 最大重试次数        retry = 0        while retry < max_retry:            try:                # 调用OpenAI GPT模型生成回复内容                response = client.chat.completions.create(                    model=self.model,  # 使用的模型名称                    messages=self.chat_history,  # 聊天历史记录                    temperature=temperature,  # 设置生成内容的“温度”影响输出的随机性                )                new_message_dict = {"role": response.choices[0].message.role,                                    "content": response.choices[0].message.content}                self.chat_history.append(new_message_dict)  # 将模型的回复添加到聊天历史中                resp = response.choices[0].message.content  # 获取模型的回复内容                return resp  # 返回模型的回复文本            except openai.OpenAIError as e:                log.logger.warning("OpenAI api retry...{}".format(e))  # 记录API调用失败的警告日志                retry += 1                time.sleep(1)  # 等待一秒后重试        log.logger.error("ERROR: OPENAI API FAILED. SKIP THIS INTERACTION.")        # 如果API调用失败，返回空字符串        return ""    def get_total_proper(self, stock_a_price, stock_b_price):        # 计算Agent的总资产值，包括股票A、股票B和现金的总和        return self.stock_a_amount * stock_a_price + self.stock_b_amount * stock_b_price + self.cash    def get_proper_cash_value(self, stock_a_price, stock_b_price):        # 计算并返回Agent的总资产值、现金价值以及股票A和股票B的各自价值        proper = self.stock_a_amount * stock_a_price + self.stock_b_amount * stock_b_price + self.cash  # 总资产值        a_value = self.stock_a_amount * stock_a_price  # 股票A的总价值        b_value = self.stock_b_amount * stock_b_price  # 股票B的总价值        return proper, self.cash, a_value, b_value  # 返回总资产值、现金价值、股票A价值和股票B价值    def get_total_loan(self):        # 计算Agent的总债务金额        debt = 0  # 初始化债务总额为0        for loan in self.loans:            debt += loan["amount"]  # 将每笔贷款的金额累加到债务总额中        return debt  # 返回总债务金额    # 设置agent的贷款计划    def plan_loan(self, date, stock_a_price, stock_b_price, lastday_forum_message):        # 如果Agent已经退出市场，直接返回不贷款        if self.quit:            return {"loan": "no"}        # 如果是第一天，使用带有背景信息的提示词        if date == 1:            prompt = Collection(BACKGROUND_PROMPT,                                LOAN_TYPE_PROMPT,                                DECIDE_IF_LOAN_PROMPT).set_indexing_method(sharp2_indexing).set_sep("\n")            max_loan = self.init_proper - self.get_total_loan()  # 计算最大可贷款金额            inputs = {                'date': date,                'character': self.character,  # Agent的性格                'stock_a': self.stock_a_amount,  # 持有的股票A数量                'stock_b': self.stock_b_amount,  # 持有的股票B数量                'cash': self.cash,  # 现金金额                'debt': self.loans,  # 已有的债务列表                'max_loan': max_loan,  # 最大可贷款金额                'loan_rate1': util.LOAN_RATE[0],  # 第一个贷款利率                'loan_rate2': util.LOAN_RATE[1],  # 第二个贷款利率                'loan_rate3': util.LOAN_RATE[2],  # 第三个贷款利率            }        # 其他日期，使用包含前一天论坛消息和股票价格的提示词        else:            prompt = Collection(BACKGROUND_PROMPT,                                LASTDAY_FORUM_AND_STOCK_PROMPT,                                LOAN_TYPE_PROMPT,                                DECIDE_IF_LOAN_PROMPT).set_indexing_method(sharp2_indexing).set_sep("\n")            max_loan = self.init_proper - self.get_total_loan()  # 计算最大可贷款金额            inputs = {                "date": date,                "character": self.character,  # Agent的性格                "stock_a": self.stock_a_amount,  # 持有的股票A数量                "stock_b": self.stock_b_amount,  # 持有的股票B数量                "cash": self.cash,  # 现金金额                "debt": self.loans,  # 已有的债务列表                "max_loan": max_loan,  # 最大可贷款金额                "stock_a_price": stock_a_price,  # 股票A的价格                "stock_b_price": stock_b_price,  # 股票B的价格                "lastday_forum_message": lastday_forum_message,  # 前一天的论坛消息                'loan_rate1': util.LOAN_RATE[0],  # 第一个贷款利率                'loan_rate2': util.LOAN_RATE[1],  # 第二个贷款利率                'loan_rate3': util.LOAN_RATE[2],  # 第三个贷款利率            }        # 如果没有可贷款的额度，直接返回不贷款        if max_loan <= 0:            return {"loan": "no"}        try_times = 0        MAX_TRY_TIMES = 3        resp = self.run_api(format_prompt(prompt, inputs))  # 使用API生成贷款决策的响应        # 如果API返回空响应，则不贷款        if resp == "":            return {"loan": "no"}        # 由secretary检查贷款格式是否正确        loan_format_check, fail_response, loan = self.secretary.check_loan(resp, max_loan)        while not loan_format_check:            try_times += 1            if try_times > MAX_TRY_TIMES:                log.logger.warning("WARNING: Loan format try times > MAX_TRY_TIMES. Skip as no loan today.")                loan = {"loan": "no"}                break            resp = self.run_api(format_prompt(LOAN_RETRY_PROMPT, {"fail_response": fail_response}))  # 重新生成贷款决策            if resp == "":                return {"loan": "no"}            loan_format_check, fail_response, loan = self.secretary.check_loan(date, resp)        # 如果贷款决定为“yes”，则更新贷款信息并增加现金        if loan["loan"] == "yes":            loan["repayment_date"] = date + util.LOAN_TYPE_DATE[loan["loan_type"]]  # 添加贷款的还款日期            self.loans.append(loan)  # 将贷款添加到债务列表中            self.cash += loan["amount"]  # 增加现金金额            log.logger.info("INFO: Agent {} decide to loan: {}".format(self.order, loan))        else:            log.logger.info("INFO: Agent {} decide not to loan".format(self.order))        return loan  # 返回贷款信息    # date=交易日, time=当前交易时段    # 设置Agent的股票交易计划    def plan_stock(self, date, time, stock_a, stock_b, stock_a_deals, stock_b_deals):        # 如果Agent已经退出市场，则直接返回不进行任何操作        if self.quit:            return {"action_type": "no"}        # 如果当前日期是季报发布日并且是第一个交易时段        if date in util.SEASON_REPORT_DAYS and time == 1:            index = util.SEASON_REPORT_DAYS.index(date)  # 获取季报发布日的索引            prompt = Collection(FIRST_DAY_FINANCIAL_REPORT, FIRST_DAY_BACKGROUND_KNOWLEDGE, SEASONAL_FINANCIAL_REPORT,                                DECIDE_BUY_STOCK_PROMPT).set_indexing_method(sharp2_indexing).set_sep("\n")            inputs = {                "date": date,                "time": time,                "stock_a": self.stock_a_amount,  # 当前持有的股票A数量                "stock_b": self.stock_b_amount,  # 当前持有的股票B数量                "stock_a_price": stock_a.get_price(),  # 股票A的价格                "stock_b_price": stock_b.get_price(),  # 股票B的价格                "stock_a_deals": stock_a_deals,  # 股票A的交易信息                "stock_b_deals": stock_b_deals,  # 股票B的交易信息                "cash": self.cash,  # 当前持有的现金                "stock_a_report": stock_a.gen_financial_report(index),  # 股票A的财报                "stock_b_report": stock_b.gen_financial_report(index)  # 股票B的财报            }        # 如果是第一个交易时段，但不是季报发布日        elif time == 1:            prompt = Collection(FIRST_DAY_FINANCIAL_REPORT, FIRST_DAY_BACKGROUND_KNOWLEDGE,                                DECIDE_BUY_STOCK_PROMPT).set_indexing_method(sharp2_indexing).set_sep("\n")            inputs = {                "date": date,                "time": time,                "stock_a": self.stock_a_amount,                "stock_b": self.stock_b_amount,                "stock_a_price": stock_a.get_price(),                "stock_b_price": stock_b.get_price(),                "stock_a_deals": stock_a_deals,                "stock_b_deals": stock_b_deals,                "cash": self.cash            }        # 其他情况下，不包含财报信息的提示词        else:            prompt = DECIDE_BUY_STOCK_PROMPT            inputs = {                "date": date,                "time": time,                "stock_a": self.stock_a_amount,                "stock_b": self.stock_b_amount,                "stock_a_price": stock_a.get_price(),                "stock_b_price": stock_b.get_price(),                "stock_a_deals": stock_a_deals,                "stock_b_deals": stock_b_deals,                "cash": self.cash            }        try_times = 0        MAX_TRY_TIMES = 3        resp = self.run_api(format_prompt(prompt, inputs))  # 通过API生成交易决策的响应        # 如果API返回空响应，则不进行任何操作        if resp == "":            return {"action_type": "no"}        # 由secretary检查交易决策的格式是否正确        action_format_check, fail_response, action = self.secretary.check_action(            resp, self.cash, self.stock_a_amount, self.stock_b_amount, stock_a.get_price(), stock_b.get_price())        while not action_format_check:            try_times += 1            if try_times > MAX_TRY_TIMES:                log.logger.warning("WARNING: Action format try times > MAX_TRY_TIMES. Skip as no loan today.")                action = {"action_type": "no"}                break            resp = self.run_api(format_prompt(BUY_STOCK_RETRY_PROMPT, {"fail_response": fail_response}))  # 重新生成交易决策            if resp == "":                return {"action_type": "no"}            action_format_check, fail_response, action = self.secretary.check_action(                resp, self.cash, self.stock_a_amount, self.stock_b_amount, stock_a.get_price(), stock_b.get_price())        # 如果决策为“买入”类型，则更新Agent的股票和现金信息        if action["action_type"] == "buy":            log.logger.info("INFO: Agent {} decide to action: {}".format(self.order, action))            return action        # 如果决策为“卖出”类型，则更新Agent的股票和现金信息        elif action["action_type"] == "sell":            log.logger.info("INFO: Agent {} decide to action: {}".format(self.order, action))            return action        # 如果决策为“不操作”，则记录并返回不进行操作        elif action["action_type"] == "no":            log.logger.info("INFO: Agent {} decide not to action".format(self.order))            return action        # 如果发生意外的操作类型，记录错误并返回不进行操作        log.logger.error("ERROR: WRONG ACTION: {}".format(action))        return {"action_type": "no"}    # 定义agent的买入股票操作    def buy_stock(self, stock_name, price, amount):        # 如果Agent已退出市场，直接返回False        if self.quit:            return False        # 检查Agent的现金是否足够购买指定数量的股票，或者股票名称是否有效        if self.cash < price * amount or stock_name not in ['A', 'B']:            log.logger.warning("ILLEGAL STOCK BUY BEHAVIOR: remain cash {}".format(self.cash))            return False        # 从现金中扣除购买股票的花费        self.cash -= price * amount        # 根据股票名称，增加对应的股票数量        if stock_name == 'A':            self.stock_a_amount += amount        elif stock_name == 'B':            self.stock_b_amount += amount        return True  # 返回购买成功    # 定义agent的卖出股票操作    def sell_stock(self, stock_name, price, amount):        # 如果Agent已退出市场，直接返回False        if self.quit:            return False        # 检查是否有足够的股票数量可供卖出        if stock_name == 'B' and self.stock_b_amount < amount:            log.logger.warning(                "ILLEGAL STOCK SELL BEHAVIOR: remain stock_b {}, amount {}".format(self.stock_b_amount, amount))            return False        elif stock_name == 'A' and self.stock_a_amount < amount:            log.logger.warning(                "ILLEGAL STOCK SELL BEHAVIOR: remain stock_a {}, amount {}".format(self.stock_a_amount, amount))            return False        # 根据股票名称，减少对应的股票数量，并增加现金        if stock_name == 'A':            self.stock_a_amount -= amount        elif stock_name == 'B':            self.stock_b_amount -= amount        self.cash += price * amount        return True  # 返回卖出成功    # 定义agent的还贷款操作    def loan_repayment(self, date):        # 如果Agent已退出市场，直接返回        if self.quit:            return        # 检查贷款是否到还款日，并处理还款逻辑        for loan in self.loans[:]:            if loan["repayment_date"] == date:                self.cash -= loan["amount"] * (1 + util.LOAN_RATE[loan["loan_type"]])  # 减去贷款本息                self.loans.remove(loan)  # 从贷款列表中移除已还清的贷款        # 如果现金为负数，标记Agent破产        if self.cash < 0:            self.is_bankrupt = True    # 定义agent的支付利息操作    def interest_payment(self):        # 如果Agent已退出市场，直接返回        if self.quit:            return        # 遍历所有贷款并支付利息        for loan in self.loans:            self.cash -= loan["amount"] * util.LOAN_RATE[loan["loan_type"]] / 12  # 每月支付利息            if self.cash < 0:  # 如果现金为负数，标记Agent破产                self.is_bankrupt = True    # 定义agent的破产操作    def bankrupt_process(self, stock_a_price, stock_b_price):        # 如果Agent已退出市场，直接返回False        if self.quit:            return False        # 计算总资产价值（股票A、股票B和现金的总和）        total_value_of_stock = self.stock_a_amount * stock_a_price + self.stock_b_amount * stock_b_price        if total_value_of_stock + self.cash < 0:            log.logger.warning(f"Agent {self.order} bankrupt. ")  # 记录破产日志            return True  # 返回破产        # 如果股票A的价值足够偿还现金负债，卖出部分股票A来偿还        if stock_a_price * self.stock_a_amount >= -self.cash:            sell_a = math.ceil(-self.cash / stock_a_price)            self.stock_a_amount -= sell_a            self.cash += sell_a * stock_a_price        else:            # 否则，卖出所有股票A并部分股票B来偿还            self.cash += stock_a_price * self.stock_a_amount            self.stock_a_amount = 0            sell_b = math.ceil(-self.cash / stock_b_price)            self.stock_b_amount -= sell_b            self.cash += sell_b * stock_b_price        # 如果股票数量或现金出现负值，抛出运行时错误        if self.stock_a_amount < 0 or self.stock_b_amount < 0 or self.cash < 0:            raise RuntimeError("ERROR: WRONG BANKRUPT PROCESS")        self.is_bankrupt = False  # 更新破产状态为False        return False  # 返回未破产    # 定义agent的上传信息prompt操作    def post_message(self):        # 如果Agent已退出市场，直接返回空字符串        if self.quit:            return ""        # 使用预定义的POST_MESSAGE_PROMPT生成prompt        prompt = format_prompt(POST_MESSAGE_PROMPT, inputs={})        # 调用API并获取响应        resp = self.run_api(prompt)        # 返回响应内容        return resp    # 定义agent的第二日预测操作    def next_day_estimate(self):        # 如果Agent已退出市场，直接返回默认的全'no'操作的估计结果        if self.quit:            return {"buy_A": "no", "buy_B": "no", "sell_A": "no", "sell_B": "no", "loan": "no"}        # 使用预定义的NEXT_DAY_ESTIMATE_PROMPT生成prompt        prompt = format_prompt(NEXT_DAY_ESTIMATE_PROMPT, inputs={})        # 调用API并获取响应        resp = self.run_api(prompt)        # 如果API响应为空，则返回默认的全'no'操作的估计结果        if resp == "":            return {"buy_A": "no", "buy_B": "no", "sell_A": "no", "sell_B": "no", "loan": "no"}        # 通过secretary类检查响应的格式并解析估计结果        format_check, fail_response, estimate = self.secretary.check_estimate(resp)        try_times = 0        MAX_TRY_TIMES = 3  # 设置最大尝试次数        # 如果格式检查未通过，则进行重试        while not format_check:            try_times += 1            if try_times > MAX_TRY_TIMES:                log.logger.warning("WARNING: Estimation format try times > MAX_TRY_TIMES. Skip as all 'no' today.")                estimate = {"buy_A": "no", "buy_B": "no", "sell_A": "no", "sell_B": "no", "loan": "no"}                break            # 根据上次失败的响应重新生成prompt并重试API调用            resp = self.run_api(format_prompt(NEXT_DAY_ESTIMATE_RETRY, {"fail_response": fail_response}))            if resp == "":                return {"buy_A": "no", "buy_B": "no", "sell_A": "no", "sell_B": "no", "loan": "no"}            # 再次进行格式检查            format_check, fail_response, estimate = self.secretary.check_estimate(resp)        # 返回最终的估计结果        return estimate